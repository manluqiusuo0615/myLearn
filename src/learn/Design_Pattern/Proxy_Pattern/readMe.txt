代理模式的作用:为其他对象提供一种代理以控制对这个对象的访问.
例子:struts2中自己写的action,都是生成一个actionProxy代理
由代理来去运行的.

代理模式一般设计到的角色有:
抽象角色:通过接口或抽象类声明真实角色实现的业务方法
        =====================================
        声明真实对象和代理对象的共同接口
代理角色:实现抽象角色,是真实角色的代理,通过真实角色
        的业务逻辑方法来实现抽象方法,并可以附加自己的操作
        ============================================
        代理对象角色内部含有对真实对象的引用,从而可以操作真实
        对象,同时代理对象提供与真实对象相同的接口以便在任何时
        刻都能代替真是对象.同时,代理对象可以在执行真实对象操作
        时,附加其他的操作,相当于对真是对象进行封装
真是角色:实现抽象角色,定义真实角色所要实现的业务逻辑,
        供代理角色调用
        =======================================
        代理角色所代表的真实对象,是我们最终要引用的对象

静态代理会造成类的一个急剧的膨胀(因为一个真是角色必须对应
一个代理角色)
如果事先并不知道真是角色,该如何使用代理

Java动态代理类位于(java.lang.reflect下),一般涉及以下两个类:
Interface InvocationHandler(调用的处理器)
InvocationHandler是代理实例的调用处理程序实现的接口
每个代理实例都具有一个关联的调用处理程序.对代理实例调用方法时,
将对方法调用进行编码并将其指派到它的调用处理程序的invoke方法
:该接口中仅定义了一个方法

public object invoke(Object proxy,Method method,Object[]args)
在实际使用时,第一个参数obj一般是指代理类,method是被代理的方法,如
上例中的request(),args为该方法的参数数组.这个抽象方法在代理中动态
实现.
在代理实例上处理方法调用并返回结果
在与方法关联的代理实例上调用方法时,将在调用处理程序上调用此方法
proxy 在其上调用方法的代理实例
method 对应于在代理实例上调用的接口方法的Method实例.Method对象
的声明类将是在其中声明方法的接口,该接口可以是代理类赖以继承方法的
代理接口的超接口.
args 包含传入代理实例上方法调用的参数值的对象数组,如果接口方法不使用参数,
则为null.基本类型的参数被包装在适当基本包装器类(如java.lang.Integer
或java.lang.Boolean)的实例中

Proxy:该类即为动态代理类,作用类似于ProxySubject
Proxy提供用于创建动态代理类和实例的静态方法,它还是由这些
方法创建的所有动态代理类的超类

所谓Dynamic Proxy是这样一种class:
它是在运行时生成的class,在生成它时你必须提供一组interface
给它,然后该class就宣称它实现了这些interface.你当然可以把
该class的实例当作这些interface中的任何一个来用.当然,这个
Dynamic Proxy其实就是一个Proxy,它不会替你做任何实质性的工作,
在生成它的实例时,你必须提供一个handler,由它接管实际的工作.

记住:jdk文档中所描述的
有一个动态代理类(newProxyInstance()方法生成的动态代理类),
就要有一个与之关联的动态代理处理器类(InvocationHandler),
因为代理类的任何方法,都会由它的代理处理器来去处理,而真正完成代理类
要执行的方法,都在代理处理器类(InvocationHandler)的invoke()方法
中完成.例如:method.invoke(sub,args);就是在invoke中执行了真实角色
要执行的方法.

通过这种方式,被代理的对象(RealSubject)可以在运行时动态改变,
需要控制的接口(Subject接口)可以在运行时改变,控制的方法(DynamicSubject类)
也可以动态改变,从而实现了非常灵活的动态代理

动态代理适合的场合:
1.调试
2.远程方法调用(RMI)

动态代理的步骤:
1.创建一个实现接口InvocationHandler的类,它必须实现invoke方法
2.创建被代理的类以及接口
3.通过Proxy的静态方法newProxyInstance(ClassLoader loader
,Class<?>[] interfaces,InvocationHandler h)创建一个代理
4.通过代理调用方法





        

