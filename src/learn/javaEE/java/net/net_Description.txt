网络编程是指编写运行在多个设备（计算机）的程序，这些设备都通过网络连接起来。
java.net 包中 J2SE 的 API 包含有类和接口，它们提供低层次的通信细节。
你可以直接使用这些类和接口，来专注于解决问题，而不用关注通信细节。
java.net 包中提供了两种常见的网络协议的支持：
    TCP：TCP 是传输控制协议的缩写，它保障了两个应用程序之间的可靠通信。通常用于互联网协议，被称 TCP / IP。
    UDP：UDP 是用户数据报协议的缩写，一个无连接的协议。提供了应用程序之间要发送的数据的数据包。
Socket 编程：是使用最广泛的网络概念，它已被解释地非常详细。
    套接字使用TCP提供了两台计算机之间的通信机制。
    客户端程序创建一个套接字，并尝试连接服务器的套接字。
    当连接建立时，服务器会创建一个Socket对象。
    客户端和服务器就可以通过对Socket对象的写入和读取来进行进行通信。
java.net.Socket 类代表一个客户端套接字
java.net.ServerSocket 类为服务器程序提供了一种来监听客户端，并与他们建立连接的机制。

以下步骤在两台计算机之间使用套接字建立TCP连接时会出现：
    服务器实例化一个 ServerSocket 对象，表示通过服务器上的端口通信。
    服务器调用 ServerSocket 类的 accept() 方法，该方法将一直等待，直到客户端连接到服务器上给定的端口。
    服务器正在等待时，一个客户端实例化一个 Socket 对象，指定服务器名称和端口号来请求连接。
    Socket 类的构造函数试图将客户端连接到指定的服务器和端口号。如果通信被建立，则在客户端创建一个 Socket 对象能够与服务器进行通信。
    在服务器端，accept() 方法返回服务器上一个新的 socket 引用，该 socket 连接到客户端的 socket。

连接建立后，通过使用 I/O 流在进行通信，每一个socket都有一个输出流和一个输入流，客户端的输出流连接到服务器端的输入流，而客户端的输入流连接到服务器端的输出流。
TCP 是一个双向的通信协议，因此数据可以通过两个数据流在同一时间发送.



"套接字"或者"插座"(Socket)也是一种软件形式的抽象,用于表达两台机器间一
个连接的"终端".针对一个特定的连接，每台机器上都有一个"套接字",可以想象
它们之间有一条虚拟的"线缆".线缆的每一端都插入一个"套接字"或者"插座"里.
当然,机器之间的物理性硬件以及电缆连接都是完全未知的.
抽象的基本宗旨是让我们尽可能不必知道那些细节.
在Java中,我们创建一个套接字,用它建立与其他机器的连接.从套接字得到的结果
是一个InputStream以及OutputStream(若使用恰当的转换器,则分别是Reader
和Writer),以便将连接作为一个IO流对象对待.有两个基于数据流的套接字类:
ServerSocket,服务器用它"侦听"进入的连接;以及Socket,客户用它初始一次连
接.一旦客户(程序)申请建立一个套接字连接,ServerSocket就会返回(通过
accept()方法)一个对应的服务器端套接字,以便进行直接通信.此时可以利用
getInputStream()以及getOutputStream()从每个套接字产生对应的InputStream
和OutputStream对象.这些数据流必须封装到缓冲区内.可对类进行格式化,就象对
待其他任何流对象那样.对于Java 库的命名机制,ServerSocket(服务器套接字)的
使用无疑是容易产生混淆的又一个例证.大家可能认为ServerSocket最好叫作
"ServerConnector"(服务器连接器),或者其他什么名字,只是不要在其中安插一个
"Socket",也可能以为ServerSocket和Socket都应从一些通用的基础类继承.事实上,
这两种类确实包含了几个通用的方法,但还不够资格把它们赋给一个通用的基础类.
相反,ServerSocket的主要任务是在那里耐心地等候其他机器同它连接,再返回一个
实际的Socket.这正是"ServerSocket"这个命名不恰当的地方,因为它的目标不是
真的成为一个Socket,而是在其他人同它连接的时候产生一个Socket 对象.
然而,ServerSocket确实会在主机上创建一个物理性的"服务器"或者侦听用的套接字.
这个套接字会侦听进入的连接,然后利用accept()方法返回一个"已建立"套接字(本地
和远程端点均已定义).容易混淆的地方是这两个套接字(侦听和已建立)都与相同的服务
器套接字关联在一起.侦听套接字只能接收新的连接请求,不能接收实际的数据包.所以尽
管ServerSocket对于编程并无太大的意义,但它确实是"物理性"的.
创建一个ServerSocket时,只需为其赋予一个端口编号.不必把一个IP地址分配它,因为
它已经在自己代表的那台机器上了.但在创建一个Socket时,却必须同时赋予IP地址以及
要连接的端口编号(另一方面,从ServerSocket.accept()返回的Socket已经包含了所
有这些信息)

套接字建立了一个"专用"连接,它会一直持续到明确断开连接为止(专用连接也可能间接性
地断开,前提是某一端或者中间的某条链路出现故障而崩溃).这意味着参与连接的双方都被
锁定在通信中,而且无论是否有数据传递,连接都会连续处于开放状态.从表面看,这似乎是一
种合理的连网方式.然而,它也为网络带来了额外的开销



































网络编程是网站、网页编程的底层基础,但与他们不相等、不同。
       网络编程，对于高级开发语言面言，多是指基于socket的编程，
       也就是面向tcp/udp的编程。
       而网页编程，多是面向http协议编程。它是以网络编程为底层基础的。
       通过网络编程的参考模型可知。

网络互联参考模型
学术界的参考模型OSI:open system interconnection
             7层：从底向上为：
	          物理层：封装的底层电气、机械特性，即0、1传输，以bit为单位
		      数据链路层：是对0、1等最基本单位的封装，成为各种传输单元。
		      网络层：将下层封装起来的数据单元从src终端传到dst终端.这里只是说计算机之间的到达,即端到端的传输。
		      传输层：上边是端到端，即机器到机器.该处即为机器内的进程到机器内的进程的传输。
		              即是tcp/udp编程的所在层。
		      会话层：维持网络联接的开始、中断、重启。
		      表示层：为应用层提供加解密、解码等操作。
		      应用层：如http、ftp、smtp等协议集中在此。像大数数的应用编程多集于此层开发。

              工业界的实际参考模型Tcp/IP：tcp and ip protocol group
               4层：从底向上：
	            osi的第1、2层合成该层:
		        网络层：
		        传输层：
		        osi的第5、6、7层合成该层：
          1.2.2 启示
	      分层的设计架构：到目前也是无处不在，是最主流的解决复杂网络、软件设计等问题的方案，即分层的设计思路。
                        包括nutch、hadoop、lucene、spark等等均是在不断的分层过程中逐渐发展壮大的。
	                    以及现在java web设计之最流行的MVC，model-view-control，即是经典的分层。

	      启示结果：解析复杂问题的最有效方法，即是分层架构设计。


	      tcp、udp优缺点
           tcp:面向链接、可靠的数据传输，
               主要在于三次握手，最后有4次握手释放链接。
               效率相对低。
               应用场景：讲究可靠、有序性，像打电话、QQ聊天、浏览器浏览网页等。
           相对来说tcp的应用范围更广。

           udp:面向无链接，不可靠的数据传输。
               效率相对高。
               应用场景：对可靠性要求不高的情况，像语音聊天、游戏场景(war3)等等





