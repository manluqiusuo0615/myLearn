HashMap,简单说是一个线性的数组结构，其中每个元素存储的是链表头结点
HashMap里实现了一个静态的内部类Entry
重要的属性有key,value,next,hash
map中的数据就存储在Entry[]中
每次我们put数据时，通过该key的hashcode,得到该key在Entry[]中的索引
然后以e.next遍历，如果存在对应value，返回value，不存在就将其添加到Entry[]
1.put(key,value)时，如果Entry[]的size超过threshold，则进行扩容，即table.length*2
2.get(key) 时先定位到该数组元素，再遍历该元素处的链表
如果我们再次放入同样的key会怎样呢？逻辑上，它应该替换老的value。事实上，它确实是这么做的。在迭代的过程中，会调用equals()方法来检查key的相等性(key.equals(k))，如果这个方法返回true，它就会用当前Entry的value来替换之前的value

1.HashMap有一个叫做Entry的内部类，它用来存储key-value对。
2.上面的Entry对象是存储在一个叫做table的Entry数组中。
3.table的索引在逻辑上叫做“桶”(bucket)，它存储了链表的第一个元素。
4.key的hashcode()方法用来找到Entry对象所在的桶。
5.如果两个key有相同的hash值，他们会被放在table数组的同一个桶里面。
6.key的equals()方法用来确保key的唯一性。
7.value对象的equals()和hashcode()方法根本一点用也没有

数组存储区间是连续的，占用内存严重，故空间复杂的很大。但数组的二分查找时间复杂度小，为O(1)；数组的特点是：寻址容易，插入和删除困难；
链表存储区间离散，占用内存比较宽松，故空间复杂度很小，但时间复杂度很大，达O（N）。链表的特点是：寻址困难，插入和删除容易。
哈希表（(Hash table）既满足了数据的查找方便，同时不占用太多的内容空间，使用也十分方便
哈希表有多种不同的实现方法(拉链法=======可以理解为“链表的数组”)
哈希表是由数组+链表组成的，一个长度为16的数组中，每个元素存储的是一个链表的头结点
一般情况是通过hash(key)%len获得，也就是元素的key的哈希值对数组长度取模得到
12%16=12,28%16=12,108%16=12,140%16=12。所以12、28、108以及140都存储在数组下标为12的位置

HashMap其实也是一个线性的数组实现的,所以可以理解为其存储数据的容器就是一个线性数组


