一个线程是一个程序内部的顺序控制流
线程和进程：
    每个进程都有独立的代码和数据空间（进程上下文），进程切换的开销大。
    线程是轻量的进程，同一类线程共享代码和数据空间，每个线程有独立的运行栈
    和程序计数器（pc），线程切换的开销小。
多进程：在操作系统中，能同时运行多个任务（程序）。
多线程：在同一个应用程序中，有多个顺序流同时执行。
线程的概念模型：
    (线程在执行过程当中，必须得到CPU资源，在java类中，由Thread模拟一个CPU)
    虚拟的CPU，封装在Java.lang.Thread类中。
    （对于CPU的话，它首先要执行代码）
    CPU所执行的代码，传递给Thread类。
    （CPU在执行过程中，也需要数据，所以cpu将数据也传递个Thread类）
    CPU所处理的数据，传递给Thread类。
线程体：
    Java的线程是通过java.lang.Thread类来实现的。
    每个线程都是通过特定Thread对象的方法run()来完成其操作的，
    方法run()称为线程体。
构造线程的两种方法：
    定义一个线程类，它继承类Thread并重写其中的方法run();
    提供一个实现接口Runnable的类作为线程的目标对象，在初始化一个
    Thread类或者Thread子类的线程对象时，把目标对象传递给这个线程实例，
    由该目标对象提供线程体run().
    public Thread(ThreadGroup group,Runnable target,String name);
通过Thread类创建线程：
    Thread类:直接继承了Object类，并实现了Runnable接口，位于java.lang包中
    Thead类封装了线程对象所需要的属性和方法。
继承Thread类------创建多线程的方法之一
    从Thread类派生一个子类,并创建子类的对象
    子类应该重写Thread类的run方法,写入需要在新线程中执行的语句段
    调用start方法来启动新线程,自动进入run方法。
线程的休眠-----线程在运行当中会调用sleep方法,让自己休眠一段时间
线程休眠的原因，就是让其它线程得到执行的机会。

通过Runnable接口创建线程:
    Runnable接口里面只有一个run()方法
    Thread类实现了Runnable接口
    便于多个线程共享资源
    Java在语法上不支持多继承，如果已经继承了某个基类,便
    需要实现Runnable接口来生成多线程
    以实现Runnable的对象为参数建立新线程

两种线程构造方式的比较：
    使用Runnable接口，可以将CPU，代码和数据分开，
    形成清晰的模型；还可以从其他类继承。
    (这里Thread表示虚拟CPU)
    直接继承Thread类,编写简单，直接继承，重写run
    方法，不能再从其他类继承

同样一个线程类，可以实例化出很多线程，这就面临着线程内部的数据共享。
用同一个实现了Runnable接口的对象作为参数创建多个线程
多个线程共享同一对象中的相同的数据

独立且同时运行的线程有时需要共享一些数据并且考虑到彼此的状态和动作。


线程的同步思路：
多线程的同步控制：（多个线程同时运行，他们之间状态是需要交互的。）
有时线程之间彼此不独立，需要同步
    线程间的互斥：
    同时运行的几个线程需要共享一个（些）数据
    共享的数据，在某一时刻只允许一个线程对其进行操作
    经典问题=====生产者/消费者  问题
    假设有一个线程负责往数据区写数据，另一个线程从同一数据区读数据，两个
    线程可以并行执行。
    如果数据区已满，生产者要等消费者取走一些数据后才能再写
    当数据区空时，消费者要等生产者写入一些数据后再取

    线程同步（synchronization）：
    互斥：许多线程再同一个共享数据上操作而互不干扰，
        同一个时刻只能有一个线程访问该共享数据，
        因此有些方法或程序段在同一时刻只能被一个线程执行，
        称之为监视区。
        线程同步往往是和我们的线程互斥在一起的。
    协作：多个线程可以有条件地同时操作共享数据。执行监视区代
        码的线程在条件满足的情况下可以允许其它线程进入监视区。


    synchronized—线程同步关键字，实现互斥
    作用：用于指定需要同步的代码段或方法，也就是监视区。
    	可实现与一个锁的交互。如：
    	synchronized（对象）{代码段}
    synchronize的功能是：首先判断对象的锁是否在，如果在就获得锁，
        然后就可以执行紧随其后的代码段；如果对象的锁不在（已被其他线程拿走），
        就进入等待状态，直到获得锁。
    当被synchronized限定的代码端执行完，就释放锁。


同步与锁的要点：
只能同步方法，而不能同步变量；
每个对象只有一个锁，当提到同步时，应该清楚再什么上同步？也就是说，再那个对象上同步。
类可以同时拥有同步和非同步方法，非同步方法可以被多个线程自由访问而不受锁的限制。
如果两个线程使用相同的实例来调用synchronized方法，那么一次只能有一个线程执行方法，
另一个需要等待锁。
线程休眠的时候，它所持有的任何锁都不会释放。
线程可以获得多个锁，比如，在一个对象的同步方法里面调用另外一个对象的同步方法，
则获取了两个对象的同步锁。
同步损害并发行，应该尽可能缩小同步范围，同步不但可以同步整个方法，
还可以同步方法中一部分代码块。











