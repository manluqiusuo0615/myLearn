# 算法分析
通过以基本的计算模型作为参照，并且以大O记号的形式在上面加入适当的刻度，   
去粗存精算    
算法分析的任务主要包括两个任务:
正确性(不变性 x 单调性) + 复杂度   
复杂度的分析和界定   
为确定后者，真的需要将算法描述为RAM的基本指令，再统计累计的执行次数？不必       
C++等高级语言的基本指令，均等效于常数条RAM的基本指令；在渐进意义下，二者大体相当       
分支转向：goto //算法的灵魂；出于结构化考虑，被隐藏了   
迭代循环：for(),while()  //本质上就是  if  + goto   
调用 + 递归(自我调用) //本质上也是goto   

复杂度分析的主要方法：
- 迭代：级数求和
- 递归：递归跟踪 + 递归方程
- 猜测 + 验证
## 级数
- 算数级数：与末项平方同阶  
T(n) = 1 + 2 + ...... + n = n(n+1)/2 = O(n^2)
- 幂方级数：比幂次高出一阶   
T2(n) = 1^2 + 2^2 + 3^2 + ... + n^2 = n(n+1)(2n+1)/6 = O(n^3)   
T3(n) = 1^3 + 2^3 + 3^3 + ... + n^3 = n^2(n+1)^2/4 = O(n^4)   
T4(n) = 1^4 + 2^4 + 3^4 + ... + n^4 = n(n+1)(2n+1)(3n^2+3n-1)/30 = O(n^5)   
...
- 几何级数(a>1):与末项同阶  
Ta(n) = a^0 + a^1 + a^2 + ... + a^n = (a^n+1 - 1)/(a - 1) = O(a^n)  
1 + 2 + 4 + ... + 2^n =  2^n+1 - 1 = O(2^n+1) = O(2^n)  
- 收敛级数  不会超过一个上界  
1/1/2 + 1/2/3 + 1/3/4 + ... + 1/(n-1)/n = 1 - 1/n = O(1)  
1+ 1/2^2 + ... + 1/n^2 < 1+1/2^2 + ... = π……2/6 = O(1)  
1/3 + 1/7 + 1/8 + 1/15 + 1/24 + 1/26 + 1/31 + 1/35 + 。。。 = 1 = O(1)  
基本操作的次数，存储单元数可能是分数？某种意义上！   
- 可能未必收敛，然而长度 有限   
h(n) = 1 + 1/2 + 1/3 + ... + 1/n = O(logn)调和级数   
log1 + log2 + log3 + ... + logn = log(n!) = O(nlogn)对数级数 
## 循环 级数
```
for(int i=0;i<n;i++){
    for(int j=0;j<n;j++){
        O10peration(i,j);
    }
}
```  
算数级数：其实是n个n累加而成
n+n+...+n = n * n = O(n^2)
```
for(int i=0;i<n;i++){
    for(int j=0;j<i;j++){
        O10peration(i,j);
    }
}
```
0+1+...+(n-1)=n(n-1)/2=O(n^2)
## 非极端元素+冒泡排序
问题：给定整数子集S，|S| = n >=3,找出元素 a属于S，a 不等于 max(S) 且 a 不等于 min(S)  
算法: 从S中任取三个元素{X,Y,Z}，确定并排除其中的最小，最大者，剩余的元素Z  
若S以数组形式给出，不妨取前三个，由于S是集合，这三个元素必互异  
不妨设X = max{x,y,z}  Y = min{x,y,z}  
无论输入规模n多大,上述算法需要的执行时间都是不变的  
T(n) = 常数 = O(1)   
起泡排序:
问题：给定n个整数，将它们按(非降)序排列   
观察：有序/无序 序列中，任意/总有 一对相邻元素 顺序/逆序
扫描交换：依次比较每一对相邻元素，如有必要，交换之，若整趟扫描都没有进行交换，则排序完成；否则，再做一趟扫描交换  
## 正确性的证明
