# 算法分析
通过以基本的计算模型作为参照，并且以大O记号的形式在上面加入适当的刻度，   
去粗存精算    
算法分析的任务主要包括两个任务:
正确性(不变性 x 单调性) + 复杂度   
复杂度的分析和界定   
为确定后者，真的需要将算法描述为RAM的基本指令，再统计累计的执行次数？不必       
C++等高级语言的基本指令，均等效于常数条RAM的基本指令；在渐进意义下，二者大体相当       
分支转向：goto //算法的灵魂；出于结构化考虑，被隐藏了   
迭代循环：for(),while()  //本质上就是  if  + goto   
调用 + 递归(自我调用) //本质上也是goto   

复杂度分析的主要方法：
- 迭代：级数求和
- 递归：递归跟踪 + 递归方程
- 猜测 + 验证
## 级数
- 算数级数：与末项平方同阶  
T(n) = 1 + 2 + ...... + n = n(n+1)/2 = O(n^2)
- 幂方级数：比幂次高出一阶   
T2(n) = 1^2 + 2^2 + 3^2 + ... + n^2 = n(n+1)(2n+1)/6 = O(n^3)   
T3(n) = 1^3 + 2^3 + 3^3 + ... + n^3 = n^2(n+1)^2/4 = O(n^4)   
T4(n) = 1^4 + 2^4 + 3^4 + ... + n^4 = n(n+1)(2n+1)(3n^2+3n-1)/30 = O(n^5)   
...
- 几何级数(a>1):与末项同阶  
Ta(n) = a^0 + a^1 + a^2 + ... + a^n = (a^n+1 - 1)/(a - 1) = O(a^n)  
1 + 2 + 4 + ... + 2^n =  2^n+1 - 1 = O(2^n+1) = O(2^n)  
- 收敛级数  不会超过一个上界  
1/1/2 + 1/2/3 + 1/3/4 + ... + 1/(n-1)/n = 1 - 1/n = O(1)  
1+ 1/2^2 + ... + 1/n^2 < 1+1/2^2 + ... = π……2/6 = O(1)  
1/3 + 1/7 + 1/8 + 1/15 + 1/24 + 1/26 + 1/31 + 1/35 + 。。。 = 1 = O(1)  
基本操作的次数，存储单元数可能是分数？某种意义上！   
- 可能未必收敛，然而长度 有限   
h(n) = 1 + 1/2 + 1/3 + ... + 1/n = O(logn)调和级数   
log1 + log2 + log3 + ... + logn = log(n!) = O(nlogn)对数级数   