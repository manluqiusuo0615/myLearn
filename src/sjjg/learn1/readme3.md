# 大O记号
上面说道的执行的次数如果是尺子的话，大O记号就是尺子上的刻度。   
但是在此我们并不需要一味的强调刻度的精细程度，而是在定性和定量之间达到一个适度的折中.   
科学记号在科学本身的发展过程种，起着至关重要的作用    
Mathematics is more in need of good motations than of new theorems.
回到原先的问题：随着问题规模的增长，计算成本如何增长？   
注意：这里更关心足够大的问题，注重考察成本的增长趋势    
渐进分析：在问题规模足够大后，计算成本如何增长？
Asymptotic analysis:   
当 n >> 2 后，对于规模为n输入，   
算法需要执行的基本操作次数：T(n) = ?     
需要占用的存储单元书:S(n) = ?  
## 渐进分析：大o记号
big -O notation
T(n) = O(f(n)) iff  c>0 ,当n>>2后,有T(n) < c.f(n)
将大写的T(n) 表示为某一个 f(n) 函数,充要条件就是，存在一个常数c,当n足够大之后，T(n) 不会超过 f(n)的常数倍   
与T(n)相比,f(n)更为简洁，但依然反映前者的增长趋势：
常系数可忽略:O(f(n))  =   O(c X f(n))
低次项可忽略：O(n的a次方  + n的b次方) = O(n的a次方),a>b>0   
## 渐进分析：其它记号
## 高效解
- 常数(constant function)
2 = 2013 = 2013*2013 = 0(1),甚至 2013的2013次方(常数的幂运算) = O(1)  //含RAM各基本操作
这类算法的效率最高   
什么样的代码段对应于常数执行时间？
如果一段代码不含显示的或者是隐示的循环（不含转向（循环，调用，递归等））,必须顺序执行,即 O(1)     
一定不含循环？   
```
for(i=0;i<n;i += n/2013 +1);
for(i=1;i<n;i = 1 << i);
```
一定不含分支转向？
```
if((n+m)*(n+m)<4*n*m) goto UNREACHABLE
```
一定不含有(递归)调用?
```
if(2 == (n*n) % 5) 01(n);
```
- 对数多项式复杂度O(logn)
常底数无所谓   
常数次幂无所谓    
对数多项式(ploy-log function)    
这类算法非常有效，复杂度无限接近于常数(O(1))
c > 0 ,logn = O(n的c次方)
- 多项式复杂度(polynomial function) O(n的次方)
所有多项式复杂度，其实所有的低此项都可忽略，即便是最高次项，常数也是可以去掉，所以，可以简明定位最高次的复杂度，
```
实例：
100n+ 200 = O(n)
(100n - 500)(20n的平方 - 300n + 2013 ) = O(nxn的平方) = O(n的三次方)
(2013n的平方 - 20)/(1999n - 1) = O(n的平方/n) = O(n)
```
- 线性复杂度(linear function)：所有O(n)类函数
## 难解
O(2的内次方)   
指数复杂度(exponential function) : T(n) = a的n次方   
对于任何 c>1 , n的c次方 = O(2的n次方)   
这类算法的计算成本增长极快，通常被认为不可忍受   

从 O(n的c次方)  到  O(2的n次方)，是从 有效算法 到 无效算法 的分水岭   
很多问题的 O(2的n次方) 算法往往显而易见，然而，设计出 O(n的c次方) 算法却及其不易，甚至，有时注定只能是徒劳无功   

给定了n个正整数，总和是2m，那么这n个正整数中是否存在几个数之和为 m?其实，就是n个整数，是否能恰好分成两部分（可能不等），这两部分的和相等.     
例如:    
各州议会选出的选举人团投票，而不是由选民直接投票，每一个地区(由历史和包括人口等因素决定的一个具体的选举人票数)所代表的票数可能不等，比如纽约31票，
加利福尼亚55票，而阿拉巴马只代表9票等。而在选举的过程中，
每一州都是要做各自独立的统计,如果某候选人，在某一个州获胜，那么代表该州的全部票数，都会归于这个候选人，
50个州加1个特区，共538票，获取270张选举人票即可当选。     
会不会出现，两位候选人，恰好各得269票的情况呢？   
直觉算法: 逐一枚举n的每一个子集，并统计其中元素的总和.    
但是我们枚举的那个子集，相对于原来那个集合来说就是不择不扣的幂集，而幂集的规模就是原来那个集合的规模,相对而言的以2为底的指数。   
定理：2的s次方 = 2的s次方 = 2的n次方    
亦即：直觉算法需要迭代2的n次轮，并(在最坏情况下)至少需要花费很多的时间，不甚理想。    
定理:2-Subset is NP -complete 问题
就目前的计算模型而言，不存在可在多项式时间内回答此问题的算法。
## 增长速度
大O尺子上的刻度：
- 2^n (增长速度最快)
- n^3
- n^2
- nlogn
- n
- sqrt(n)
- logn
复杂度的典型层次：O(logn),O(sqrt(n)),O(n),O(nlog*n),O(n^2),O(n^3),O(2^n)



